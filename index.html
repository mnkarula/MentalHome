<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>黑胶唱片播放器 (最终优化版 v4 - Drag Fix)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* ---------------------- 基础样式重置 ---------------------- */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Inter', sans-serif;
      line-height: 1.6;
      background-color: var(--color-bg);
      color: var(--color-text);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 50px 15px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overscroll-behavior: none;
    }

    /* ---------------------- CSS变量与全局主题 ---------------------- */
    :root {
      --color-bg: #f4f3f1;
      --color-text: #333;
      --color-secondary: #6a11cb;
      --color-accent: #2575fc;
      --color-base: #e6e2dc;
      --color-record: #1a1a1a;
      --color-record-groove: #3a3a3a; /* Moiré Tweak */
      --color-error-bg: rgba(200, 50, 50, 0.85);
      --color-error-text: #fff;
      --shadow-light: rgba(255, 255, 255, 0.8);
      --shadow-dark: rgba(184, 181, 176, 0.6);
      --transition-fast: 0.3s ease;
      --focus-outline-color: var(--color-accent);
    }

    /* ---------------------- 播放器容器 ---------------------- */
    .container {
      width: 100%;
      max-width: 420px;
    }
    .player-section {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    /* ---------------------- 黑胶播放器主体 ---------------------- */
    .vinyl-player-wrapper {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 2.5rem;
      max-width: 100%;
    }
    .player-base {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: linear-gradient(145deg, var(--color-base), #ffffff);
      box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light),
                  inset 0 -3px 10px rgba(0, 0, 0, 0.05);
      z-index: 0;
    }

    /* ---------------------- 黑胶唱片样式 ---------------------- */
    .record {
      position: absolute;
      width: 95%;
      height: 95%;
      top: 2.5%;
      left: 2.5%;
      border-radius: 50%;
      background-color: var(--color-record);
      /* Moiré Tweak 2 */
      background-image:
        radial-gradient(circle at center, #333 10%, transparent 50%),
        repeating-radial-gradient(
          circle at center,
          var(--color-record),
          var(--color-record) 0.7px,
          var(--color-record-groove) 0.7px,
          var(--color-record-groove) 4px
        );
      background-size: 100% 100%, 100% 100%;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 12px 2px rgba(30, 30, 30, 0.3),
                  0 4px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2;
      transition: box-shadow var(--transition-fast);
      will-change: transform;
      user-select: none;
      -webkit-user-drag: none;

      animation: spin 4s linear infinite;
      animation-play-state: paused;
    }

    .record.playing {
      animation-play-state: running;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 12px 2px rgba(30, 30, 30, 0.3),
                  0 4px 10px rgba(0, 0, 0, 0.2), 0 0 10px rgba(255, 255, 255, 0.08);
    }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* ---------------------- 唱片封面 ---------------------- */
    #album-art {
      width: 35%;
      height: 35%;
      border-radius: 50%;
      object-fit: cover;
      border: 5px solid #111;
      background-color: #333;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 4;
      position: relative;
      transition: transform var(--transition-fast);
      color: #aaa;
      font-size: 10px;
      text-align: center;
      line-height: 1.2;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .record.playing #album-art { transform: scale(1.03); }

    /* ---------------------- 唱臂 (Tonearm) ---------------------- */
    .tonearm {
      position: absolute;
      top: calc(50% - 135px);
      right: calc(50% - 135px);
      width: 1px;
      height: 1px;
      z-index: 10;
    }
    .tonearm-rotator {
      position: absolute;
      width: 180px;
      height: 20px;
      bottom: -10px;
      left: -10px;
      transform-origin: 10px 10px;
      transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      z-index: 1;
      transform: rotate(70deg); /* Initial resting angle */
      will-change: transform;
    }
    .tonearm-bar {
      position: absolute;
      top: 6px;
      left: 10px;
      width: 175px;
      height: 8px;
      background-color: #aaa;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      z-index: 10;
      cursor: pointer;
      will-change: transform;
    }

    /* ---------------------- 歌曲信息 ---------------------- */
    .song-info {
      text-align: center;
      margin-bottom: 1.5rem;
      width: 100%;
      padding: 0 1rem;
    }
    .song-info h2 {
      font-size: 1.2rem;
      font-weight: 500;
      color: var(--color-text);
      margin-bottom: 0.2rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }
    .song-info h4 {
      font-size: 0.9rem;
      font-weight: 400;
      color: #777;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    /* ---------------------- 进度条 ---------------------- */
    .progress-container {
      width: 100%;
      height: 10px;
      background-color: #e0dcd7;
      border-radius: 5px;
      margin: 0.5rem 0 1rem;
      overflow: hidden;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.15);
      cursor: pointer;
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, var(--color-secondary), var(--color-accent));
      border-radius: 5px;
      transition: width 0.1s linear;
      pointer-events: none;
    }

    /* ---------------------- 时间显示 ---------------------- */
    .time-display {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 0 0.5rem;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 1.5rem;
    }

    /* ---------------------- 控制按钮 ---------------------- */
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
      padding: 0 5px;
    }
    .control-group { display: flex; align-items: center; }
    .prev-next-group { gap: 15px; }
    .control-item { display: flex; flex-direction: column; align-items: center; text-align: center; }
    .control-button {
      background: linear-gradient(145deg, var(--color-base), #fff);
      border: none;
      cursor: pointer;
      box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light),
                  inset 1px 1px 2px var(--shadow-light), inset -1px -1px 2px var(--shadow-dark);
      transition: all 0.3s ease-out;
      color: #555;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 6px;
      border-radius: 50%;
      touch-action: manipulation;
    }
    .prev-next-group .control-button { width: 52px; height: 52px; padding: 12px; }
    #play-pause-button { width: 119px; height: 52px; padding: 12px 20px; border-radius: 26px; }
    .control-button:hover {
      background: linear-gradient(145deg, #fff, var(--color-base));
      color: #333;
      box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light);
    }
    .control-button:active,
    .control-button.playing {
      box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
      transform: translateY(1px);
      color: #444;
    }
    .control-button:focus-visible { outline: 2px solid var(--focus-outline-color); outline-offset: 2px; }
    .control-label { font-size: 0.7rem; color: #777; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.2; }
    .control-button svg { width: 20px; height: 20px; display: block; fill: currentColor; }
    #play-pause-button .icon-pause { display: none; }
    #play-pause-button.playing .icon-play { display: none; }
    #play-pause-button.playing .icon-pause { display: inline-block; }

    /* ---------------------- 加载与错误指示 ---------------------- */
    .loading-indicator, .error-message {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 15; display: none;
    }
    .loading-indicator {
      width: 30px; height: 30px; border: 3px solid rgba(0, 0, 0, 0.2); border-radius: 50%; border-top-color: #666; animation: spin 1s ease-in-out infinite;
    }
    .error-message {
      background-color: var(--color-error-bg); color: var(--color-error-text); padding: 8px 12px; border-radius: 5px; font-size: 0.85rem; text-align: center; max-width: 80%; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .vinyl-player-wrapper.loading .loading-indicator { display: block; }
    .vinyl-player-wrapper.error .error-message { display: block; }
    .vinyl-player-wrapper.empty .error-message { display: block; }

    /* ---------------------- 响应式适配 ---------------------- */
    @media (max-width: 480px) { /* Styles for 480px and below */ }
    @media (max-width: 360px) { /* Styles for 360px and below */ }
    /* (Keeping responsive styles collapsed for brevity) */
     @media (max-width: 480px) {
      body { padding: 30px 10px; }
      .vinyl-player-wrapper { width: 260px; height: 260px; margin-bottom: 2rem; }
      .tonearm { top: calc(50% - 120px); right: calc(50% - 120px); }
      .tonearm-rotator { width: 150px; height: 16px; bottom: -8px; left: -8px; transform-origin: 8px 8px;}
      .tonearm-bar { width: 140px; left: 8px; top: 4px; height: 6px; border-radius: 3px; }
      .song-info h2 { font-size: 1.1rem; }
      .song-info h4 { font-size: 0.85rem; }
      .progress-container { height: 8px; border-radius: 4px; }
      .progress-bar { border-radius: 4px; }
      .prev-next-group { gap: 10px; }
      .prev-next-group .control-button { width: 46px; height: 46px; padding: 10px; }
      #play-pause-button { width: 102px; height: 46px; padding: 10px 15px; border-radius: 23px; }
      .control-label { font-size: 0.65rem; }
      .control-button svg { width: 18px; height: 18px; }
    }
    @media (max-width: 360px) {
      .vinyl-player-wrapper { width: 220px; height: 220px; }
      .tonearm { top: calc(50% - 105px); right: calc(50% - 105px); }
      .tonearm-rotator { width: 125px; height: 14px; bottom: -7px; left: -7px; transform-origin: 7px 7px;}
      .tonearm-bar { width: 115px; left: 7px; top: 4px; height: 6px; border-radius: 3px;}
      .controls { padding: 0; }
      .prev-next-group { gap: 8px; }
      .prev-next-group .control-button { width: 42px; height: 42px; padding: 9px; }
      #play-pause-button { width: 94px; height: 42px; padding: 9px 12px; border-radius: 21px; }
      .control-button svg { width: 16px; height: 16px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="player-section">
      <!-- Visuals -->
      <div class="vinyl-player-wrapper" id="player-wrapper">
        <div class="player-base"></div>
        <div class="record" id="record">
          <img id="album-art" src="" alt="唱片封面">
        </div>
        <div class="tonearm" id="tonearm-base">
          <div class="tonearm-rotator" id="tonearm-rotator">
            <div class="tonearm-bar"></div>
          </div>
        </div>
        <div class="loading-indicator"></div>
        <div class="error-message" id="error-message">音频加载失败</div>
      </div>

      <!-- Audio Element -->
      <audio id="audio-player" preload="metadata">您的浏览器不支持音频元素。</audio>

      <!-- Info & Controls -->
      <div class="song-info">
        <h2 id="song-title">加载中...</h2>
        <h4 id="song-artist"></h4>
      </div>
      <div class="progress-container" id="progress-container" role="slider" aria-label="歌曲进度" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div class="time-display">
        <span id="current-time">0:00</span>
        <span id="duration">0:00</span>
      </div>
      <div class="controls">
        <div class="control-group play-group">
          <div class="control-item">
            <button id="play-pause-button" class="control-button" aria-label="播放">
              <svg class="icon-play" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
              <svg class="icon-pause" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
            </button>
            <span class="control-label" id="play-pause-label">播放</span>
          </div>
        </div>
        <div class="control-group prev-next-group">
          <div class="control-item">
            <button id="prev-button" class="control-button" aria-label="上一首">
              <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"></path></svg>
            </button>
            <span class="control-label" id="prev-label">上一首</span>
          </div>
          <div class="control-item">
            <button id="next-button" class="control-button" aria-label="下一首">
              <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></svg>
            </button>
            <span class="control-label" id="next-label">下一首</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // Constants
    const TONEARM_ANGLES = { RESTING: 70, START: 100 };
    const TONEARM_DRAG_LIMITS = { MIN: 65, MAX: 110 };

    // DOM Elements Cache
    const elements = { /* (Keeping collapsed for brevity) */
        audioPlayer: document.getElementById('audio-player'),
        playPauseButton: document.getElementById('play-pause-button'),
        playPauseLabel: document.getElementById('play-pause-label'),
        record: document.getElementById('record'),
        tonearmBase: document.getElementById('tonearm-base'),
        tonearmRotator: document.getElementById('tonearm-rotator'),
        tonearmBar: document.querySelector('.tonearm-bar'),
        prevButton: document.getElementById('prev-button'),
        nextButton: document.getElementById('next-button'),
        albumArt: document.getElementById('album-art'),
        songTitle: document.getElementById('song-title'),
        songArtist: document.getElementById('song-artist'),
        progressContainer: document.getElementById('progress-container'),
        progressBar: document.getElementById('progress-bar'),
        currentTimeDisplay: document.getElementById('current-time'),
        durationDisplay: document.getElementById('duration'),
        loadingIndicator: document.querySelector('.loading-indicator'),
        errorMessage: document.getElementById('error-message'),
        playerWrapper: document.getElementById('player-wrapper')
    };

    // Player State
    const state = { /* (Keeping collapsed for brevity) */
        isPlaying: false, isLoading: false, hasError: false, isEmpty: false,
        currentTrackIndex: 0, progressAnimId: null, isDraggingTonearm: false,
        tonearmDragStartAngle: 0, isDraggingProgress: false, wasPlayingBeforeDrag: false,
        playlist: [
            { title: "SoundHelix Song 1", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3", albumArt: "https://picsum.photos/seed/song1/200/200" },
            { title: "SoundHelix Song 2", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3", albumArt: "https://picsum.photos/seed/song2/200/200" },
            { title: "SoundHelix Song 3", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3", albumArt: "https://picsum.photos/seed/song3/200/200" }
        ]
    };

    // Utility Functions
    const utils = { /* (Keeping collapsed for brevity) */
        formatTime: (seconds) => { /* ... */
            const time = Math.max(0, seconds || 0);
            const minutes = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        },
        throttle: (func, limit) => { /* ... */
            let inThrottle;
            return function(...args) {
              if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
              }
            }
        },
        getAngleRelativeToPivot: (clientX, clientY) => { /* ... */
            const rect = elements.tonearmBase.getBoundingClientRect();
            let pivotOffsetX = 10, pivotOffsetY = 10;
            if (window.innerWidth <= 480 && window.innerWidth > 360) { pivotOffsetX = 8; pivotOffsetY = 8; }
            else if (window.innerWidth <= 360) { pivotOffsetX = 7; pivotOffsetY = 7; }
            const pivotX = rect.left + pivotOffsetX;
            const pivotY = rect.top + pivotOffsetY;
            const angleRad = Math.atan2(clientY - pivotY, clientX - pivotX);
            return angleRad * (180 / Math.PI);
        },
        getEventCoords: (e) => { /* ... */
            if (e.touches && e.touches.length > 0) return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
            if (e.changedTouches && e.changedTouches.length > 0) return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
            return { clientX: e.clientX, clientY: e.clientY };
        }
    };

    // Player Logic
    const player = {
        // State Setters (Loading, Error, Empty, Controls Enabled)
        setLoadingState(isLoading) { /* ... */
            if (state.isLoading === isLoading) return;
            state.isLoading = isLoading;
            elements.playerWrapper.classList.toggle('loading', isLoading);
            if (isLoading) player.setErrorState(false);
            player.setControlsEnabled(!isLoading && !state.hasError && !state.isEmpty);
        },
        setErrorState(hasError, message = "音频加载失败") { /* ... */
            state.hasError = hasError;
            elements.playerWrapper.classList.toggle('error', hasError);
            if (hasError) {
              elements.errorMessage.textContent = message;
              player.setLoadingState(false);
              if (state.isPlaying) {
                state.isPlaying = false;
                player.updateButtonUI(false);
                player.updateVisuals(false);
                player.stopProgressAnimation();
              }
            }
            player.setControlsEnabled(!state.isLoading && !hasError && !state.isEmpty);
        },
        setEmptyState(isEmpty) { /* ... */
             state.isEmpty = isEmpty;
            elements.playerWrapper.classList.toggle('empty', isEmpty);
            if (isEmpty) {
              elements.errorMessage.textContent = "播放列表为空";
              elements.songTitle.textContent = "无歌曲";
              elements.songArtist.textContent = "";
              elements.albumArt.src = "https://via.placeholder.com/200?text=Empty";
              if (state.isPlaying) {
                 state.isPlaying = false;
                 player.updateButtonUI(false);
                 player.updateVisuals(false);
                 player.stopProgressAnimation();
              }
            }
            player.setControlsEnabled(!state.isLoading && !state.hasError && !isEmpty);
        },
        setControlsEnabled(enabled) { /* ... */
            const effectiveEnabled = enabled && !state.isLoading && !state.hasError && !state.isEmpty;
            if (elements.playPauseButton.disabled === effectiveEnabled) { // Check if update needed
              elements.playPauseButton.disabled = !effectiveEnabled;
              elements.prevButton.disabled = !effectiveEnabled;
              elements.nextButton.disabled = !effectiveEnabled;
              const pointerEvents = effectiveEnabled ? 'auto' : 'none';
              const cursor = effectiveEnabled ? 'pointer' : 'default';
              elements.progressContainer.style.pointerEvents = pointerEvents;
              elements.progressContainer.style.cursor = cursor;
              elements.tonearmBar.style.pointerEvents = pointerEvents;
              elements.tonearmBar.style.cursor = cursor;
            }
        },

        // UI Updaters
        updateButtonUI(isPlaying) { /* ... */
            elements.playPauseButton.classList.toggle('playing', isPlaying);
            elements.playPauseLabel.textContent = isPlaying ? '暂停' : '播放';
            elements.playPauseButton.setAttribute('aria-label', isPlaying ? '暂停' : '播放');
        },
        updateVisuals(isPlaying) { /* ... */
            elements.record.classList.toggle('playing', isPlaying);
            if (!state.isDraggingTonearm) {
              const targetAngle = isPlaying ? TONEARM_ANGLES.START : TONEARM_ANGLES.RESTING;
              elements.tonearmRotator.style.transform = `rotate(${targetAngle}deg)`;
            }
        },
        updateProgressBar() { /* ... */
            const { duration, currentTime } = elements.audioPlayer;
            const isValid = duration && !isNaN(duration) && duration > 0;
            const progress = isValid ? currentTime / duration : 0;
            if (!state.isDraggingProgress) {
                elements.progressBar.style.width = `${progress * 100}%`;
            }
            elements.currentTimeDisplay.textContent = utils.formatTime(currentTime);
            elements.durationDisplay.textContent = utils.formatTime(duration);
            elements.progressContainer.setAttribute('aria-valuenow', isValid ? Math.round(currentTime) : 0);
            elements.progressContainer.setAttribute('aria-valuemax', isValid ? Math.round(duration) : 100);
            elements.progressContainer.setAttribute('aria-valuetext', `当前 ${utils.formatTime(currentTime)} / 总时长 ${utils.formatTime(duration)}`);
        },

        // Progress Animation
        startProgressAnimation() { /* ... */
            player.stopProgressAnimation();
            function animationStep() {
              if (state.isPlaying && !state.isDraggingTonearm && !state.isDraggingProgress) {
                  player.updateProgressBar();
                  state.progressAnimId = requestAnimationFrame(animationStep);
              }
            }
            if (state.isPlaying) {
               state.progressAnimId = requestAnimationFrame(animationStep);
            }
        },
        stopProgressAnimation() { /* ... */
            if (state.progressAnimId) {
              cancelAnimationFrame(state.progressAnimId);
              state.progressAnimId = null;
            }
        },

        // Core Playback Logic
        loadTrack(trackIndex, autoPlay = false) { /* ... */
            if (state.isEmpty || trackIndex < 0 || trackIndex >= state.playlist.length) {
                if (state.playlist.length === 0) player.setEmptyState(true);
                return;
            }
            player.stopProgressAnimation();
            player.setLoadingState(true);
            player.setErrorState(false);
            state.currentTrackIndex = trackIndex;
            const track = state.playlist[trackIndex];
            elements.songTitle.textContent = track.title;
            elements.songArtist.textContent = track.artist;
            elements.albumArt.src = "https://via.placeholder.com/100?text=Load";
            elements.albumArt.alt = "加载封面中...";
            const img = new Image();
            img.onload = () => { elements.albumArt.src = img.src; elements.albumArt.alt = `封面: ${track.title}`; };
            img.onerror = () => { elements.albumArt.src = "https://via.placeholder.com/200?text=No+Cover"; elements.albumArt.alt = "无法加载封面"; };
            img.src = track.albumArt || "https://via.placeholder.com/200?text=No+Cover";
            if (!elements.audioPlayer.paused) {
                elements.audioPlayer.pause();
            }
            state.isPlaying = false;
            player.updateButtonUI(false);
            player.updateVisuals(false);
            elements.audioPlayer.src = track.audioSrc;
            elements.audioPlayer.currentTime = 0;
            elements.audioPlayer.load();
            player.updateProgressBar();
            const readyHandler = () => {
                player.setLoadingState(false);
                player.updateProgressBar();
                player.setControlsEnabled(true);
                if (autoPlay) {
                    setTimeout(() => player.playAudio(), 50);
                }
            };
            elements.audioPlayer.removeEventListener('loadeddata', player._currentReadyHandler);
            elements.audioPlayer.removeEventListener('error', player._currentErrorHandler);
            player._currentReadyHandler = readyHandler;
            player._currentErrorHandler = (e) => player.handleAudioError(e, trackIndex);
            elements.audioPlayer.addEventListener('loadeddata', player._currentReadyHandler, { once: true });
            elements.audioPlayer.addEventListener('error', player._currentErrorHandler, { once: true });
        },
        handleAudioError(e, trackIndex) { /* ... */
           const error = elements.audioPlayer.error;
           let message = "音频加载/播放失败";
           if (error) {
             switch (error.code) {
               case MediaError.MEDIA_ERR_NETWORK: message = "网络错误，无法加载"; break;
               case MediaError.MEDIA_ERR_DECODE: message = "音频解码错误"; break;
               case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: message = "音频格式不支持"; break;
               default: message = `发生错误 (Code ${error.code})`;
             }
           }
           if (state.currentTrackIndex === trackIndex && (!error || error.code !== MediaError.MEDIA_ERR_ABORTED)) {
               player.setErrorState(true, message);
           }
        },
        playAudio() { /* ... */
            if (state.isPlaying || state.isLoading || state.hasError || state.isEmpty) { return; }
            if (elements.audioPlayer.readyState < elements.audioPlayer.HAVE_FUTURE_DATA) {
                player.setLoadingState(true);
                 elements.audioPlayer.addEventListener('loadeddata', () => {
                     if (!state.isPlaying && !state.hasError) { // Check again
                        player.setLoadingState(false);
                        player.playAudio();
                     }
                 }, { once: true });
                return;
            }
            const playPromise = elements.audioPlayer.play();
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                if (error.name !== 'AbortError') {
                     player.handleAudioError(error, state.currentTrackIndex);
                     // Ensure UI reflects actual state if play fails
                     state.isPlaying = false;
                     player.updateButtonUI(false);
                     player.updateVisuals(false);
                }
              });
            }
        },
        pauseAudio() { /* ... */
             if (!state.isPlaying) return;
            elements.audioPlayer.pause();
        },
        playNextTrack() { /* ... */
             if (state.isEmpty) return;
            const nextIndex = (state.currentTrackIndex + 1) % state.playlist.length;
            player.loadTrack(nextIndex, true);
        },
        playPrevTrack() { /* ... */
            if (state.isEmpty) return;
            if (elements.audioPlayer.currentTime < 3) {
              const prevIndex = (state.currentTrackIndex - 1 + state.playlist.length) % state.playlist.length;
              player.loadTrack(prevIndex, true);
            } else {
              elements.audioPlayer.currentTime = 0;
              if (!state.isPlaying) { player.playAudio(); }
            }
        },
        togglePlayPause() { /* ... */
             if (state.isLoading || state.hasError || state.isEmpty) return;
            if (state.isPlaying) { player.pauseAudio(); }
            else { player.playAudio(); }
        },

        // Interaction Handlers
        handleProgressClick(e) { /* ... */
            if (state.isLoading || state.hasError || state.isEmpty || state.isDraggingProgress) return;
            const { duration } = elements.audioPlayer;
            if (!duration || isNaN(duration) || duration <= 0) return;
            const rect = elements.progressContainer.getBoundingClientRect();
            const { clientX } = utils.getEventCoords(e);
            const clickX = clientX - rect.left;
            const clickProgress = Math.min(1, Math.max(0, clickX / rect.width));
            elements.audioPlayer.currentTime = clickProgress * duration;
            player.updateProgressBar();
        },
        handleTonearmMouseDown(e) { /* ... */
             if (state.isLoading || state.hasError || state.isEmpty) return;
            const { clientX, clientY } = utils.getEventCoords(e);
            state.isDraggingTonearm = true;
            const currentRotation = parseFloat(elements.tonearmRotator.style.transform.replace('rotate(', '').replace('deg)', '')) || TONEARM_ANGLES.RESTING;
            const mouseAngle = utils.getAngleRelativeToPivot(clientX, clientY);
            state.tonearmDragStartAngle = mouseAngle - currentRotation;
            player.stopProgressAnimation();
            elements.tonearmRotator.style.transition = 'none';
        },
        handleTonearmMouseMove(e) { /* ... */
            if (!state.isDraggingTonearm) return;
            const { clientX, clientY } = utils.getEventCoords(e);
            const mouseAngle = utils.getAngleRelativeToPivot(clientX, clientY);
            let targetRotation = mouseAngle - state.tonearmDragStartAngle;
            targetRotation = Math.max(TONEARM_DRAG_LIMITS.MIN, Math.min(TONEARM_DRAG_LIMITS.MAX, targetRotation));
            elements.tonearmRotator.style.transform = `rotate(${targetRotation}deg)`;
            const progressRangeStart = TONEARM_ANGLES.RESTING;
            const progressRangeEnd = TONEARM_ANGLES.START;
            const progress = Math.max(0, Math.min(1, (targetRotation - progressRangeStart) / (progressRangeEnd - progressRangeStart)));
            const { duration } = elements.audioPlayer;
            if (duration && !isNaN(duration) && duration > 0) {
                elements.audioPlayer.currentTime = progress * duration;
                player.updateProgressBar();
            }
        },
        handleTonearmMouseUp(e) { /* ... */
             if (!state.isDraggingTonearm) return;
            state.isDraggingTonearm = false;
            elements.tonearmRotator.style.transition = '';
            const finalRotation = parseFloat(elements.tonearmRotator.style.transform.replace('rotate(', '').replace('deg)', '')) || TONEARM_ANGLES.RESTING;
            if (Math.abs(finalRotation - TONEARM_ANGLES.START) < Math.abs(finalRotation - TONEARM_ANGLES.RESTING)) {
                elements.tonearmRotator.style.transform = `rotate(${TONEARM_ANGLES.START}deg)`;
                if (!state.isPlaying) player.playAudio();
                else player.startProgressAnimation();
            } else {
                elements.tonearmRotator.style.transform = `rotate(${TONEARM_ANGLES.RESTING}deg)`;
                if (state.isPlaying) player.pauseAudio();
            }
        },
        handleProgressMouseDown(e) { /* ... */
            if (state.isLoading || state.hasError || state.isEmpty) return;
            e.preventDefault();
            state.isDraggingProgress = true;
            state.wasPlayingBeforeDrag = state.isPlaying;
            player.stopProgressAnimation();
            if (state.wasPlayingBeforeDrag) {
               elements.audioPlayer.pause(); // Pause directly
            }
            player.handleProgressDrag(e); // Update UI immediately
        },
        handleProgressMouseMove: utils.throttle((e) => { /* ... */
             if (!state.isDraggingProgress) return;
            player.handleProgressDrag(e);
        }, 50),

        // --- MODIFIED: handleProgressMouseUp ---
        handleProgressMouseUp(e) {
            if (!state.isDraggingProgress) return;
            state.isDraggingProgress = false;

            // Ensure final position is visually updated (even if throttled)
            player.handleProgressDrag(e);

            // If it was playing before, attempt to resume with a slight delay
            if (state.wasPlayingBeforeDrag) {
                // Use setTimeout to allow state to settle after drag/currentTime updates
                setTimeout(() => {
                    // Double-check the element is actually paused and no error occurred
                    if (elements.audioPlayer.paused && !state.hasError) {
                        // console.log("Resuming playback after progress drag (via direct play).");
                        const resumePromise = elements.audioPlayer.play();
                        if (resumePromise !== undefined) {
                            resumePromise.catch(error => {
                                // console.error("Error resuming playback after drag:", error);
                                if (error.name !== 'AbortError') {
                                    player.handleAudioError(error, state.currentTrackIndex);
                                }
                                // Ensure UI reflects actual paused state if resume fails
                                if (state.isPlaying) { // Check if state thinks it's playing
                                     state.isPlaying = false; // Correct the state
                                     player.updateButtonUI(false);
                                     player.updateVisuals(false);
                                }
                            });
                        }
                    } else {
                         // console.log("Audio not resuming: Already playing or error present.");
                         // If it's somehow playing again already (e.g. very fast interaction), ensure animation starts
                         if (state.isPlaying) {
                             player.startProgressAnimation();
                         }
                    }
                }, 10); // Small delay (10ms) seems sufficient usually
            }
            // Reset the flag regardless of whether play was attempted
            state.wasPlayingBeforeDrag = false;
        },
        // --- END MODIFICATION ---

        handleProgressDrag(e) { /* ... */
             const { duration } = elements.audioPlayer;
            if (!duration || isNaN(duration) || duration <= 0) return;
            const rect = elements.progressContainer.getBoundingClientRect();
            const { clientX } = utils.getEventCoords(e);
            const clickX = clientX - rect.left;
            const progress = Math.min(1, Math.max(0, clickX / rect.width));
            // This directly sets the time, potentially triggering internal browser events
            elements.audioPlayer.currentTime = progress * duration;
            // Update visuals immediately during drag for responsiveness
            elements.progressBar.style.width = `${progress * 100}%`;
            elements.currentTimeDisplay.textContent = utils.formatTime(elements.audioPlayer.currentTime);
            elements.progressContainer.setAttribute('aria-valuenow', Math.round(elements.audioPlayer.currentTime));
            elements.progressContainer.setAttribute('aria-valuetext', `当前 ${utils.formatTime(elements.audioPlayer.currentTime)} / 总时长 ${utils.formatTime(duration)}`);
        }
    };

    // --- Event Listener Setup ---
    const setupEventListeners = () => {
      elements.playPauseButton.addEventListener('click', player.togglePlayPause);
      elements.prevButton.addEventListener('click', player.playPrevTrack);
      elements.nextButton.addEventListener('click', player.playNextTrack);

      // Progress Bar Interaction
      elements.progressContainer.addEventListener('click', player.handleProgressClick);
      elements.progressContainer.addEventListener('mousedown', player.handleProgressMouseDown);
      elements.progressContainer.addEventListener('touchstart', player.handleProgressMouseDown, { passive: false });

      // Tonearm Interaction
      elements.tonearmBar.addEventListener('mousedown', player.handleTonearmMouseDown);
      elements.tonearmBar.addEventListener('touchstart', player.handleTonearmMouseDown, { passive: false });

      // Document-level listeners for dragging
      document.addEventListener('mousemove', (e) => {
          player.handleProgressMouseMove(e); // Throttled
          player.handleTonearmMouseMove(e); // Not throttled (usually smoother)
      });
      document.addEventListener('touchmove', (e) => {
          if (state.isDraggingProgress) { player.handleProgressMouseMove(e); e.preventDefault(); }
          if (state.isDraggingTonearm) { player.handleTonearmMouseMove(e); e.preventDefault(); }
      }, { passive: false });
      document.addEventListener('mouseup', (e) => {
          player.handleProgressMouseUp(e);
          player.handleTonearmMouseUp(e);
      });
      document.addEventListener('touchend', (e) => {
          player.handleProgressMouseUp(e);
          player.handleTonearmMouseUp(e);
      });
       document.addEventListener('touchcancel', (e) => {
          player.handleProgressMouseUp(e);
          player.handleTonearmMouseUp(e);
      });

      // Keyboard Controls
      document.addEventListener('keydown', (e) => { /* ... */
         const activeEl = document.activeElement;
        const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'BUTTON' || activeEl.isContentEditable);
        if (e.code === 'Space' && !isInputFocused) {
          e.preventDefault();
          player.togglePlayPause();
        }
      });

      // --- Audio Element Events ---
      elements.audioPlayer.addEventListener('play', () => {
        state.isPlaying = true; // Update state FIRST
        player.updateButtonUI(true);
        player.updateVisuals(true);
        player.startProgressAnimation();
         if (state.isLoading) { player.setLoadingState(false); } // Hide loading if playing starts
      });
      elements.audioPlayer.addEventListener('pause', () => {
        state.isPlaying = false; // Update state FIRST
        // Update UI only if not paused temporarily by drag start
        if (!state.isDraggingProgress) {
            player.updateButtonUI(false);
            player.updateVisuals(false);
            player.stopProgressAnimation();
        }
      });
      elements.audioPlayer.addEventListener('ended', player.playNextTrack);
      elements.audioPlayer.addEventListener('timeupdate', () => {
          if (!state.isDraggingTonearm && !state.isDraggingProgress) {
              player.updateProgressBar();
          }
      });
      elements.audioPlayer.addEventListener('loadedmetadata', () => {
        player.updateProgressBar();
        player.setControlsEnabled(true);
      });
       elements.audioPlayer.addEventListener('waiting', () => {
            if (state.isPlaying && !state.isLoading) { player.setLoadingState(true); }
       });
       elements.audioPlayer.addEventListener('playing', () => { // After waiting/seek resumes
           if (state.isLoading) { player.setLoadingState(false); }
           // Ensure state/UI matches if needed (e.g., if 'play' didn't fire)
           if(!state.isPlaying) {
                state.isPlaying = true;
                player.updateButtonUI(true);
                player.updateVisuals(true);
           }
           player.startProgressAnimation();
       });

      // Album Art Error Fallback
      elements.albumArt.addEventListener('error', () => { /* ... */
        if (elements.albumArt.src && !elements.albumArt.src.includes("placeholder.com")) {
            elements.albumArt.src = "https://via.placeholder.com/200?text=No+Cover";
            elements.albumArt.alt = "无法加载封面";
        }
      });
    };

    // --- Initialization ---
    const init = () => {
      setupEventListeners();
      player.setControlsEnabled(false);
      if (!state.playlist || state.playlist.length === 0) { player.setEmptyState(true); }
      else { player.setEmptyState(false); player.loadTrack(0, false); }
    };

    // Run init once DOM is ready
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); }
    else { init(); }

  </script>
</body>
</html>