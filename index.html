<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>黑胶唱片播放器 (最终优化版 v7 - Fixes)</title> <!-- Version updated -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* ---------------------- 基础样式重置 ---------------------- */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Inter', sans-serif; line-height: 1.6;
      background-color: var(--color-bg); color: var(--color-text);
      display: flex; justify-content: center; align-items: flex-start;
      min-height: 100vh; padding: 50px 15px;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      overscroll-behavior: none;
    }

    /* ---------------------- CSS变量与全局主题 ---------------------- */
    :root {
      --color-bg: #f4f3f1; --color-text: #333; --color-secondary: #6a11cb;
      --color-accent: #2575fc; --color-base: #e6e2dc; --color-record: #1a1a1a;
      --color-record-groove: #3a3a3a; --color-error-bg: rgba(200, 50, 50, 0.85);
      --color-error-text: #fff; --shadow-light: rgba(255, 255, 255, 0.8);
      --shadow-dark: rgba(184, 181, 176, 0.6); --transition-fast: 0.3s ease;
      --focus-outline-color: var(--color-accent);
      --touch-target-min-height: 44px; /* Minimum recommended touch height */
      --progress-bar-height: 10px; /* Default visual height */
      --progress-bar-height-mobile: 12px; /* Slightly taller visual on mobile */
    }

    /* ---------------------- 播放器容器 ---------------------- */
    .container { width: 100%; max-width: 420px; }
    .player-section { position: relative; display: flex; flex-direction: column; align-items: center; width: 100%; }

    /* ---------------------- 黑胶播放器主体 ---------------------- */
    .vinyl-player-wrapper { position: relative; width: 300px; height: 300px; margin-bottom: 2.5rem; max-width: 100%; }
    .player-base { position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(145deg, var(--color-base), #ffffff); box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light), inset 0 -3px 10px rgba(0, 0, 0, 0.05); z-index: 0; }

    /* ---------------------- 黑胶唱片样式 ---------------------- */
    .record {
        position: absolute; width: 95%; height: 95%; top: 2.5%; left: 2.5%; border-radius: 50%;
        background-color: var(--color-record);
        background-image: radial-gradient(circle at center, #333 10%, transparent 50%), repeating-radial-gradient( circle at center, var(--color-record), var(--color-record) 0.7px, var(--color-record-groove) 0.7px, var(--color-record-groove) 1.1px );
        background-size: 100% 100%, 100% 100%;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 12px 2px rgba(30, 30, 30, 0.3), 0 4px 10px rgba(0, 0, 0, 0.2);
        display: flex; justify-content: center; align-items: center; z-index: 2;
        transition: box-shadow var(--transition-fast); will-change: transform; user-select: none; -webkit-user-drag: none;
        animation: spin 4s linear infinite; animation-play-state: paused;
    }
    .record.playing { animation-play-state: running; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 12px 2px rgba(30, 30, 30, 0.3), 0 4px 10px rgba(0, 0, 0, 0.2), 0 0 10px rgba(255, 255, 255, 0.08); }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* ---------------------- 唱片封面 ---------------------- */
    #album-art { width: 35%; height: 35%; border-radius: 50%; object-fit: cover; border: 5px solid #111; background-color: #333; box-shadow: 0 1px 3px rgba(0,0,0,0.3); z-index: 4; position: relative; transition: transform var(--transition-fast); color: #aaa; font-size: 10px; text-align: center; line-height: 1.2; display: flex; justify-content: center; align-items: center; }
    .record.playing #album-art { transform: scale(1.03); }

    /* ---------------------- 唱臂 (Tonearm) ---------------------- */
    .tonearm { position: absolute; top: calc(50% - 135px); right: calc(50% - 135px); width: 1px; height: 1px; z-index: 10; }
    .tonearm-rotator { position: absolute; width: 180px; height: 20px; bottom: -10px; left: -10px; transform-origin: 10px 10px; transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); z-index: 1; transform: rotate(70deg); will-change: transform; }
    .tonearm-bar {
      position: absolute; top: 6px; left: 10px;
      width: 175px; height: 8px; /* Visual height */
      background-color: #aaa; border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      z-index: 10; cursor: pointer; will-change: transform;
      position: relative; /* Needed for pseudo-element positioning */
    }
    .tonearm-bar::after { /* Invisible touch area expansion */
      content: ''; position: absolute; top: 50%; left: -5px; right: -5px;
      height: var(--touch-target-min-height); transform: translateY(-50%);
      /* background: rgba(0, 255, 0, 0.1); */ /* Uncomment to visualize */
    }

    /* ---------------------- 歌曲信息 (Aligned Left) ---------------------- */
    .song-info {
      text-align: left; /* Changed from center */
      margin-bottom: 1.5rem;
      width: 100%;
      padding: 0 5px; /* Match controls padding */
    }
    .song-info h2 { font-size: 1.2rem; font-weight: 500; color: var(--color-text); margin-bottom: 0.2rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    .song-info h4 { font-size: 0.9rem; font-weight: 400; color: #777; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }

    /* ---------------------- 进度条 (Touch Target Enhanced v2) ---------------------- */
    .progress-container {
      width: 100%;
      height: var(--progress-bar-height); /* Visual height */
      background-color: #e0dcd7;
      border-radius: calc(var(--progress-bar-height) / 2); /* Dynamic radius */
      margin: 1rem 0; /* Consistent margin */
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.15);
      cursor: pointer;
      position: relative; /* Needed for pseudo-element */
      -webkit-tap-highlight-color: transparent;
      overflow: hidden; /* Ensure progress bar respects border-radius */
    }
    /* Invisible pseudo-element to increase touch area vertically */
    .progress-container::before {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        /* Calculate top/bottom to achieve target height centered on visual bar */
        top: calc( (var(--progress-bar-height) - var(--touch-target-min-height)) / 2 );
        bottom: calc( (var(--progress-bar-height) - var(--touch-target-min-height)) / 2 );
        /* background: rgba(255, 0, 0, 0.1); */ /* Uncomment to visualize */
        z-index: 0; /* Place behind the actual bar if needed, or just rely on container handling */
    }
    .progress-bar {
      height: 100%; /* Fill the container's visual height */
      width: 0%;
      background: linear-gradient(to right, var(--color-secondary), var(--color-accent));
      border-radius: inherit; /* Inherit radius from container - THIS IS KEY */
      transition: width 0.1s linear;
      pointer-events: none; /* Bar itself is not interactive */
    }

    /* ---------------------- 时间显示 ---------------------- */
    .time-display { display: flex; justify-content: space-between; width: 100%; padding: 0 0.5rem; font-size: 0.8rem; color: #666; margin-bottom: 1.5rem; }

    /* ---------------------- 控制按钮 (Updated Style) ---------------------- */
    .controls {
      display: flex; justify-content: space-between; align-items: flex-start;
      width: 100%; padding: 0 5px;
      /* margin-top: 1rem; */ /* Base margin-top if needed */
    }
    .control-group { display: flex; align-items: center; }
    .prev-next-group { gap: 15px; }
    .control-item { display: flex; flex-direction: column; align-items: center; text-align: center; }
    .control-button {
      background: linear-gradient(145deg, var(--color-base), #fff);
      border: 1px solid rgba(0, 0, 0, 0.5); /* Subtle black border */
      cursor: pointer;
      /* Combined neumorphic + subtle inset + border shadow */
      box-shadow: 3px 3px 6px var(--shadow-dark),
                  -3px -3px 6px var(--shadow-light),
                  inset 1px 1px 2px var(--shadow-light), /* Subtle highlight inside */
                  inset -1px -1px 2px var(--shadow-dark); /* Subtle shadow inside */
      transition: all 0.2s ease-out; /* Slightly faster transition */
      color: #555;
      display: flex; justify-content: center; align-items: center;
      margin-bottom: 6px; border-radius: 50%;
      touch-action: manipulation;
    }
    .prev-next-group .control-button { width: 52px; height: 52px; padding: 12px; }
    #play-pause-button { width: 119px; height: 52px; padding: 12px 20px; border-radius: 26px; }
    .control-button:hover:not(:disabled) {
        background: linear-gradient(145deg, #fff, var(--color-base)); color: #333;
        box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light); /* Hover shadow slightly less intense */
        border-color: rgba(0, 0, 0, 0.15);
    }
    .control-button:active:not(:disabled), .control-button.playing:not(:disabled) {
        /* Enhanced inset shadow for "pressed" / "active" look */
        box-shadow: inset 3px 3px 6px rgba(184, 181, 176, 0.7), /* Darker inset */
                  inset -2px -2px 5px rgba(255, 255, 255, 0.9); /* Lighter inset */
        transform: translateY(1px);
        color: #444;
        border-color: rgba(0, 0, 0, 0.2); /* Slightly darker border when pressed */
    }
    .control-button:focus-visible { outline: 2px solid var(--focus-outline-color); outline-offset: 2px; }
    .control-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: 1px 1px 2px var(--shadow-dark), -1px -1px 2px var(--shadow-light); /* Flatter shadow when disabled */
        background: var(--color-base);
    }

    .control-label { font-size: 0.7rem; color: #777; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.2; }
    .control-button svg { /* Kept for potential future use, but not displayed now */
        width: 20px; height: 20px; display: block; fill: currentColor; display: none; /* Hide SVGs */
    }
    /* Remove specific icon display logic
    #play-pause-button .icon-pause { display: none; }
    #play-pause-button.playing .icon-play { display: none; }
    #play-pause-button.playing .icon-pause { display: inline-block; } */

    /* ---------------------- 加载与错误指示 ---------------------- */
    .loading-indicator, .error-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 15; display: none; }
    .loading-indicator { width: 30px; height: 30px; border: 3px solid rgba(0, 0, 0, 0.2); border-radius: 50%; border-top-color: #666; animation: spin 1s ease-in-out infinite; }
    .error-message { background-color: var(--color-error-bg); color: var(--color-error-text); padding: 8px 12px; border-radius: 5px; font-size: 0.85rem; text-align: center; max-width: 80%; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .vinyl-player-wrapper.loading .loading-indicator { display: block; }
    .vinyl-player-wrapper.error .error-message { display: block; }
    .vinyl-player-wrapper.empty .error-message { display: block; }

    /* ---------------------- 响应式适配 (Increased Margins) ---------------------- */
    @media (max-width: 480px) {
      body { padding: 30px 10px; }
      .vinyl-player-wrapper { width: 260px; height: 260px; margin-bottom: 2rem; }
      .tonearm { top: calc(50% - 120px); right: calc(50% - 120px); }
      .tonearm-rotator { width: 150px; height: 16px; bottom: -8px; left: -8px; transform-origin: 8px 8px;}
      .tonearm-bar { width: 140px; left: 8px; top: 4px; height: 6px; border-radius: 3px; }
      .tonearm-bar::after { height: var(--touch-target-min-height); }

      .song-info { padding: 0 5px; /* Match controls */ }
      .song-info h2 { font-size: 1.1rem; }
      .song-info h4 { font-size: 0.85rem; }

      .progress-container {
          height: var(--progress-bar-height-mobile); /* Use mobile height variable */
          margin: 1.5rem 0; /* Increased vertical margin */
      }
      /* ::before pseudo-element adjusts automatically based on container height */

      .controls { margin-top: 1.5rem; /* Increased top margin */ }
      .prev-next-group { gap: 10px; }
      .prev-next-group .control-button { width: 46px; height: 46px; padding: 10px; }
      #play-pause-button { width: 102px; height: 46px; padding: 10px 15px; border-radius: 23px; }
      .control-label { font-size: 0.65rem; }
      /* .control-button svg { width: 18px; height: 18px; } */ /* SVG size irrelevant now */
    }
    @media (max-width: 360px) {
      .vinyl-player-wrapper { width: 220px; height: 220px; }
      .tonearm { top: calc(50% - 105px); right: calc(50% - 105px); }
      .tonearm-rotator { width: 125px; height: 14px; bottom: -7px; left: -7px; transform-origin: 7px 7px;}
      .tonearm-bar { width: 115px; left: 7px; top: 4px; height: 6px; border-radius: 3px;}
      .tonearm-bar::after { height: var(--touch-target-min-height); }

      .song-info { padding: 0; /* Align with controls */ }
      .controls { padding: 0; margin-top: 1.2rem; /* Adjust margin if needed */ }
      .progress-container { margin: 1.2rem 0; /* Adjust margin */ }

      .prev-next-group { gap: 8px; }
      .prev-next-group .control-button { width: 42px; height: 42px; padding: 9px; }
      #play-pause-button { width: 94px; height: 42px; padding: 9px 12px; border-radius: 21px; }
      /* .control-button svg { width: 16px; height: 16px; } */ /* SVG size irrelevant now */
    }

  </style>
</head>
<body>
  <!-- HTML structure: Updated buttons -->
  <div class="container">
    <div class="player-section">
       <!-- Visuals -->
      <div class="vinyl-player-wrapper" id="player-wrapper">
        <div class="player-base"></div>
        <div class="record" id="record">
          <img id="album-art" src="" alt="唱片封面">
        </div>
        <div class="tonearm" id="tonearm-base">
          <div class="tonearm-rotator" id="tonearm-rotator">
            <div class="tonearm-bar"></div>
          </div>
        </div>
        <div class="loading-indicator"></div>
        <div class="error-message" id="error-message">音频加载失败</div>
      </div>

      <!-- Audio Element -->
      <audio id="audio-player" preload="metadata">您的浏览器不支持音频元素。</audio>

      <!-- Info & Controls -->
      <div class="song-info">
        <h2 id="song-title">加载中...</h2>
        <h4 id="song-artist"></h4>
      </div>
      <div class="progress-container" id="progress-container" role="slider" aria-label="歌曲进度" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
         <!-- Enhanced touch area via ::before -->
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div class="time-display">
        <span id="current-time">0:00</span>
        <span id="duration">0:00</span>
      </div>
      <div class="controls">
         <!-- Controls structure: Updated buttons -->
         <div class="control-group play-group">
            <div class="control-item">
                <!-- Play/Pause Button: No SVG -->
                <button id="play-pause-button" class="control-button" aria-label="Play/Pause">
                 <!-- Icons removed -->
                </button>
                <!-- Label always "PLAY" -->
                <span class="control-label" id="play-pause-label">PLAY</span>
            </div>
            </div>
            <div class="control-group prev-next-group">
            <div class="control-item">
                 <!-- Prev Button: No SVG -->
                <button id="prev-button" class="control-button" aria-label="Previous">
                 <!-- Icon removed -->
                </button>
                <!-- Label changed to "Previous" -->
                <span class="control-label" id="prev-label">Previous</span>
            </div>
            <div class="control-item">
                 <!-- Next Button: No SVG -->
                <button id="next-button" class="control-button" aria-label="Next">
                 <!-- Icon removed -->
                </button>
                 <!-- Label changed to "Next" -->
                <span class="control-label" id="next-label">Next</span>
            </div>
            </div>
      </div>
    </div>
  </div>

  <script type="module">
    // --- Constants ---
    const TONEARM_ANGLES = { RESTING: 70, START: 100 };
    const TONEARM_DRAG_LIMITS = { MIN: 65, MAX: 110 };

    // --- DOM Elements Cache ---
    const elements = {
        audioPlayer: document.getElementById('audio-player'),
        playPauseButton: document.getElementById('play-pause-button'),
        playPauseLabel: document.getElementById('play-pause-label'), // Kept for reference, but text is static now
        record: document.getElementById('record'),
        tonearmBase: document.getElementById('tonearm-base'),
        tonearmRotator: document.getElementById('tonearm-rotator'),
        tonearmBar: document.querySelector('.tonearm-bar'),
        prevButton: document.getElementById('prev-button'),
        nextButton: document.getElementById('next-button'),
        albumArt: document.getElementById('album-art'),
        songTitle: document.getElementById('song-title'),
        songArtist: document.getElementById('song-artist'),
        progressContainer: document.getElementById('progress-container'),
        progressBar: document.getElementById('progress-bar'),
        currentTimeDisplay: document.getElementById('current-time'),
        durationDisplay: document.getElementById('duration'),
        loadingIndicator: document.querySelector('.loading-indicator'),
        errorMessage: document.getElementById('error-message'),
        playerWrapper: document.getElementById('player-wrapper')
    };

    // --- Player State ---
    const state = {
        isPlaying: false,
        isLoading: false,
        hasError: false,
        isEmpty: false,
        currentTrackIndex: 0,
        progressAnimId: null,
        isDraggingTonearm: false,
        tonearmDragStartAngle: 0,
        isDraggingProgress: false,
        wasPlayingBeforeDrag: false,
        playlist: [ // Example playlist
            { title: "SoundHelix Song 1", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3", albumArt: "https://picsum.photos/seed/song1/200/200" },
            { title: "SoundHelix Song 2", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3", albumArt: "https://picsum.photos/seed/song2/200/200" },
            { title: "SoundHelix Song 3", artist: "SoundHelix", audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3", albumArt: "https://picsum.photos/seed/song3/200/200" }
        ]
    };

    // --- Utility Functions ---
    const utils = {
        formatTime: (seconds) => {
            const time = Math.max(0, seconds || 0);
            const minutes = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        },
        throttle: (func, limit) => {
            let inThrottle;
            return function(...args) {
              if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
              }
            }
        },
        getAngleRelativeToPivot: (clientX, clientY) => {
            const rect = elements.tonearmBase.getBoundingClientRect();
            let pivotOffsetX = 10, pivotOffsetY = 10;
            // Adjust pivot based on media query size changes affecting tonearm structure
            if (window.innerWidth <= 480 && window.innerWidth > 360) { pivotOffsetX = 8; pivotOffsetY = 8; }
            else if (window.innerWidth <= 360) { pivotOffsetX = 7; pivotOffsetY = 7; }
            const pivotX = rect.left + pivotOffsetX;
            const pivotY = rect.top + pivotOffsetY;
            const angleRad = Math.atan2(clientY - pivotY, clientX - pivotX);
            return angleRad * (180 / Math.PI);
        },
        getEventCoords: (e) => {
            if (e.touches && e.touches.length > 0) return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
            if (e.changedTouches && e.changedTouches.length > 0) return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
            return { clientX: e.clientX, clientY: e.clientY };
        }
    };

    // --- Player Logic ---
    const player = {
        setLoadingState(isLoading) {
            if (state.isLoading === isLoading) return;
            state.isLoading = isLoading;
            elements.playerWrapper.classList.toggle('loading', isLoading);
            if (isLoading) {
                player.setErrorState(false);
            }
            player.setControlsEnabled(!isLoading && !state.hasError && !state.isEmpty);
        },

        setErrorState(hasError, message = "音频加载失败") {
            if (state.hasError === hasError && !hasError) return;
            state.hasError = hasError;
            elements.playerWrapper.classList.toggle('error', hasError);
            if (hasError) {
                elements.errorMessage.textContent = message;
                player.setLoadingState(false);
                if (state.isPlaying) {
                    state.isPlaying = false;
                    player.updateButtonUI(false);
                    player.updateVisuals(false);
                    player.stopProgressAnimation();
                }
            } else {
                 elements.errorMessage.textContent = "";
            }
            player.setControlsEnabled(!state.isLoading && !state.hasError && !state.isEmpty);
        },

        setEmptyState(isEmpty) {
            if (state.isEmpty === isEmpty) return;
            state.isEmpty = isEmpty;
            elements.playerWrapper.classList.toggle('empty', isEmpty);
            if (isEmpty) {
                elements.errorMessage.textContent = "播放列表为空";
                elements.songTitle.textContent = "无歌曲";
                elements.songArtist.textContent = "";
                elements.albumArt.src = "https://via.placeholder.com/200?text=Empty";
                if (state.isPlaying) {
                    state.isPlaying = false;
                    player.updateButtonUI(false);
                    player.updateVisuals(false);
                    player.stopProgressAnimation();
                }
            }
            player.setControlsEnabled(!state.isLoading && !state.hasError && !isEmpty);
        },

        setControlsEnabled(enabled) {
            const effectiveEnabled = enabled && !state.isLoading && !state.hasError && !state.isEmpty;
             // Direct comparison might not work if `disabled` property was changed elsewhere.
             // Always set the property based on `effectiveEnabled`.
            elements.playPauseButton.disabled = !effectiveEnabled;
            elements.prevButton.disabled = !effectiveEnabled;
            elements.nextButton.disabled = !effectiveEnabled;

            const pointerEvents = effectiveEnabled ? 'auto' : 'none';
            const cursor = effectiveEnabled ? 'pointer' : 'default';

            // Only update styles if they need changing
            if (elements.progressContainer.style.pointerEvents !== pointerEvents) {
                elements.progressContainer.style.pointerEvents = pointerEvents;
                elements.progressContainer.style.cursor = cursor;
            }
            if (elements.tonearmBar.style.pointerEvents !== pointerEvents) {
                elements.tonearmBar.style.pointerEvents = pointerEvents;
                 elements.tonearmBar.style.cursor = cursor;
            }
        },

        updateButtonUI(isPlaying) {
            // Only toggle the 'playing' class for visual state (like pressed effect)
            elements.playPauseButton.classList.toggle('playing', isPlaying);
            // Label text remains "PLAY"
            // elements.playPauseLabel.textContent = isPlaying ? '暂停' : '播放'; // Removed
            // Aria label is static now
            // elements.playPauseButton.setAttribute('aria-label', isPlaying ? '暂停' : '播放'); // Removed
        },

        updateVisuals(isPlaying) {
            elements.record.classList.toggle('playing', isPlaying);
            if (!state.isDraggingTonearm) {
                const targetAngle = isPlaying ? TONEARM_ANGLES.START : TONEARM_ANGLES.RESTING;
                elements.tonearmRotator.style.transform = `rotate(${targetAngle}deg)`;
            }
        },

        updateProgressBar() {
            const { duration, currentTime } = elements.audioPlayer;
            const isValid = duration && !isNaN(duration) && duration > 0;
            const progress = isValid ? currentTime / duration : 0;
            if (!state.isDraggingProgress) {
                elements.progressBar.style.width = `${progress * 100}%`;
            }
            elements.currentTimeDisplay.textContent = utils.formatTime(currentTime);
            elements.durationDisplay.textContent = utils.formatTime(duration);
            elements.progressContainer.setAttribute('aria-valuenow', isValid ? Math.round(currentTime) : 0);
            elements.progressContainer.setAttribute('aria-valuemax', isValid ? Math.round(duration) : 100);
            elements.progressContainer.setAttribute('aria-valuetext', `当前 ${utils.formatTime(currentTime)} / 总时长 ${utils.formatTime(duration)}`);
        },

        startProgressAnimation() {
            player.stopProgressAnimation();
            function animationStep() {
                if (state.isPlaying && !state.isDraggingTonearm && !state.isDraggingProgress && !state.isLoading && !state.hasError) {
                    player.updateProgressBar();
                    state.progressAnimId = requestAnimationFrame(animationStep);
                } else {
                    player.stopProgressAnimation();
                }
            }
            if (state.isPlaying && !state.isDraggingTonearm && !state.isDraggingProgress && !state.isLoading && !state.hasError) {
               state.progressAnimId = requestAnimationFrame(animationStep);
            }
        },

        stopProgressAnimation() {
            if (state.progressAnimId) {
                cancelAnimationFrame(state.progressAnimId);
                state.progressAnimId = null;
            }
        },

        loadTrack(trackIndex, autoPlay = false) {
            if (state.isEmpty || trackIndex < 0 || trackIndex >= state.playlist.length) {
                if (state.playlist.length === 0) player.setEmptyState(true);
                return;
            }

            player.stopProgressAnimation();
            player.setLoadingState(true);
            player.setErrorState(false);

            if (!elements.audioPlayer.paused) {
                elements.audioPlayer.pause();
            }
            state.isPlaying = false;
            player.updateButtonUI(false);
            player.updateVisuals(false);

            state.currentTrackIndex = trackIndex;
            const track = state.playlist[trackIndex];

            elements.songTitle.textContent = track.title;
            elements.songArtist.textContent = track.artist;

            elements.albumArt.src = "https://via.placeholder.com/100?text=Load";
            elements.albumArt.alt = "加载封面中...";
            const img = new Image();
            img.onload = () => { elements.albumArt.src = img.src; elements.albumArt.alt = `封面: ${track.title}`; };
            img.onerror = () => { elements.albumArt.src = "https://via.placeholder.com/200?text=No+Cover"; elements.albumArt.alt = "无法加载封面"; };
            img.src = track.albumArt || "https://via.placeholder.com/200?text=No+Cover";

            elements.audioPlayer.src = track.audioSrc;
            elements.audioPlayer.currentTime = 0;
            elements.audioPlayer.load();

            player.updateProgressBar();

            const readyHandler = () => {
                player.setLoadingState(false);
                player.updateProgressBar();
                player.setControlsEnabled(true);
                if (autoPlay) {
                    setTimeout(() => player.playAudio(), 50);
                }
            };

            elements.audioPlayer.removeEventListener('loadeddata', player._currentReadyHandler);
            elements.audioPlayer.removeEventListener('error', player._currentErrorHandler);

            player._currentReadyHandler = readyHandler;
            player._currentErrorHandler = (e) => player.handleAudioError(e, trackIndex);

            elements.audioPlayer.addEventListener('loadeddata', player._currentReadyHandler, { once: true });
            elements.audioPlayer.addEventListener('error', player._currentErrorHandler, { once: true });
        },

        handleAudioError(e, trackIndex) {
           const error = elements.audioPlayer.error;
           let message = "音频加载/播放失败";
           if (error) {
             switch (error.code) {
               case MediaError.MEDIA_ERR_ABORTED: message = "加载中止"; break; // Added specific message
               case MediaError.MEDIA_ERR_NETWORK: message = "网络错误，无法加载"; break;
               case MediaError.MEDIA_ERR_DECODE: message = "音频解码错误"; break;
               case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: message = "音频格式不支持"; break;
               default: message = `发生错误 (Code ${error.code})`;
             }
           } else if (e && e.type === 'error' && !error) {
               // Sometimes the event fires but the error object is null?
               message = "未知播放错误";
           }

           // Only show error if it's for the *currently intended* track and not an abort by user/load
           if (state.currentTrackIndex === trackIndex && (!error || error.code !== MediaError.MEDIA_ERR_ABORTED)) {
               console.error(`Audio Error (Track ${trackIndex}, Code: ${error?.code}):`, message, e);
               player.setErrorState(true, message);
           } else {
               // Log aborts or errors for other tracks for debugging, but don't show user
                // console.warn(`Audio event ignored (Track ${trackIndex}, Current: ${state.currentTrackIndex}, Code: ${error?.code}):`, message, e);
                // If it's an abort or for a different track, ensure loading is off if it was on
                if (state.isLoading) {
                    player.setLoadingState(false);
                }
           }
        },

        playAudio() {
            if (state.isPlaying || state.isLoading || state.hasError || state.isEmpty) { return; }

             // Ready state check remains important
            if (elements.audioPlayer.readyState < elements.audioPlayer.HAVE_METADATA) {
                player.setLoadingState(true);
                 // Use a named function for the listener to allow removal if needed
                 const retryPlayOnLoad = () => {
                     if (!state.isPlaying && !state.hasError && !state.isLoading) {
                        player.playAudio();
                     } else {
                        player.setLoadingState(false);
                     }
                 };
                 elements.audioPlayer.addEventListener('loadeddata', retryPlayOnLoad, { once: true });
                return;
            }

            const playPromise = elements.audioPlayer.play();

            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    // AbortError is common if user rapidly clicks play/pause or loads new track
                    if (error.name !== 'AbortError') {
                         // console.error("Playback failed:", error);
                        player.handleAudioError(error, state.currentTrackIndex);
                        // Ensure state reflects reality if play fails
                        if (state.isPlaying) { state.isPlaying = false; }
                        player.updateButtonUI(false);
                        player.updateVisuals(false);
                        player.stopProgressAnimation(); // Stop animation if play fails
                    } else {
                        // console.warn("Playback aborted, likely by user action.");
                         // If aborted, ensure UI reflects paused state if it's still marked as playing
                         if (state.isPlaying) {
                            state.isPlaying = false;
                            player.updateButtonUI(false);
                            player.updateVisuals(false);
                            player.stopProgressAnimation();
                         }
                    }
                });
            }
            // 'play' event listener will handle successful playback start UI updates
        },

        pauseAudio() {
            if (!state.isPlaying || state.isLoading || state.hasError) return;
            elements.audioPlayer.pause();
            // 'pause' event listener handles UI updates
        },

        playNextTrack() {
            if (state.isEmpty || state.isLoading) return;
            const nextIndex = (state.currentTrackIndex + 1) % state.playlist.length;
            player.loadTrack(nextIndex, true);
        },

        playPrevTrack() {
            if (state.isEmpty || state.isLoading) return;
            // Always go to previous track index or wrap around if near start
            if (elements.audioPlayer.currentTime < 3) {
                 const prevIndex = (state.currentTrackIndex - 1 + state.playlist.length) % state.playlist.length;
                 player.loadTrack(prevIndex, true);
            } else {
                 // If not near the start, just restart current track
                 elements.audioPlayer.currentTime = 0;
                 if (!state.isPlaying) {
                    player.playAudio(); // Need to explicitly play if paused
                 } else {
                    player.startProgressAnimation(); // Ensure animation continues if already playing
                 }
            }
        },

        togglePlayPause() {
            if (state.isLoading || state.hasError || state.isEmpty) return;
            if (state.isPlaying) {
                player.pauseAudio();
            } else {
                player.playAudio();
            }
        },

        handleProgressClick(e) {
            if (state.isLoading || state.hasError || state.isEmpty || state.isDraggingProgress) return;
            const { duration } = elements.audioPlayer;
            if (!duration || isNaN(duration) || duration <= 0) return;

            const rect = elements.progressContainer.getBoundingClientRect();
            const { clientX } = utils.getEventCoords(e);
            const clickX = clientX - rect.left;
            const clickProgress = Math.min(1, Math.max(0, clickX / rect.width));

            elements.audioPlayer.currentTime = clickProgress * duration;
            player.updateProgressBar();
            if (!state.isPlaying) {
                 const targetAngle = TONEARM_ANGLES.RESTING + (TONEARM_ANGLES.START - TONEARM_ANGLES.RESTING) * clickProgress;
                 const clampedAngle = Math.max(TONEARM_ANGLES.RESTING, Math.min(TONEARM_ANGLES.START, targetAngle));
                 elements.tonearmRotator.style.transform = `rotate(${clampedAngle}deg)`;
            }
        },

        handleTonearmMouseDown(e) {
            if (state.isLoading || state.hasError || state.isEmpty) return;
            const { clientX, clientY } = utils.getEventCoords(e);
            state.isDraggingTonearm = true;
            document.body.style.userSelect = 'none'; // Prevent text selection during drag (Fix for sticky)
            const currentRotation = parseFloat(elements.tonearmRotator.style.transform.replace(/rotate\(|\)deg/g, '')) || TONEARM_ANGLES.RESTING;
            const mouseAngle = utils.getAngleRelativeToPivot(clientX, clientY);
            state.tonearmDragStartAngle = mouseAngle - currentRotation;
            player.stopProgressAnimation();
            elements.tonearmRotator.style.transition = 'none';
        },

        handleTonearmMouseMove(e) {
            if (!state.isDraggingTonearm) return;
            const { clientX, clientY } = utils.getEventCoords(e);
            const mouseAngle = utils.getAngleRelativeToPivot(clientX, clientY);
            let targetRotation = mouseAngle - state.tonearmDragStartAngle;
            targetRotation = Math.max(TONEARM_DRAG_LIMITS.MIN, Math.min(TONEARM_DRAG_LIMITS.MAX, targetRotation));
            elements.tonearmRotator.style.transform = `rotate(${targetRotation}deg)`;

            const progressRangeStart = TONEARM_ANGLES.RESTING;
            const progressRangeEnd = TONEARM_ANGLES.START;
            const progress = Math.max(0, Math.min(1, (targetRotation - progressRangeStart) / (progressRangeEnd - progressRangeStart)));
            const { duration } = elements.audioPlayer;
            if (duration && !isNaN(duration) && duration > 0) {
                // Avoid rapid-fire seeks if value is essentially the same
                const newTime = progress * duration;
                 if (Math.abs(elements.audioPlayer.currentTime - newTime) > 0.1) {
                     elements.audioPlayer.currentTime = newTime;
                 }
                player.updateProgressBar();
            }
        },

        handleTonearmMouseUp(e) {
            if (!state.isDraggingTonearm) return;
            state.isDraggingTonearm = false;
            document.body.style.userSelect = ''; // Re-enable text selection
            elements.tonearmRotator.style.transition = '';
            const finalRotation = parseFloat(elements.tonearmRotator.style.transform.replace(/rotate\(|\)deg/g, '')) || TONEARM_ANGLES.RESTING;

            // Snap based on proximity
            if (Math.abs(finalRotation - TONEARM_ANGLES.START) < Math.abs(finalRotation - TONEARM_ANGLES.RESTING)) {
                elements.tonearmRotator.style.transform = `rotate(${TONEARM_ANGLES.START}deg)`;
                if (!state.isPlaying) {
                    player.playAudio();
                } else {
                    player.startProgressAnimation(); // Resume animation if already playing
                }
            } else {
                elements.tonearmRotator.style.transform = `rotate(${TONEARM_ANGLES.RESTING}deg)`;
                if (state.isPlaying) {
                    player.pauseAudio();
                }
            }
        },

        handleProgressMouseDown(e) {
            if (state.isLoading || state.hasError || state.isEmpty) return;
            // Allow interaction only with the primary mouse button (button 0)
            if (e.button !== 0 && !(e.type.startsWith('touch'))) return;
            e.preventDefault();
            state.isDraggingProgress = true;
            document.body.style.userSelect = 'none'; // Prevent selection during drag
            state.wasPlayingBeforeDrag = state.isPlaying;
            player.stopProgressAnimation();

            if (state.wasPlayingBeforeDrag) {
               elements.audioPlayer.pause(); // Triggers 'pause' event
            }
             // Update position immediately based on initial click/touch
            player.handleProgressDrag(e); // Call this to set initial position
        },

        handleProgressMouseMove: utils.throttle((e) => {
             if (!state.isDraggingProgress) return;
            player.handleProgressDrag(e);
        }, 50),

        handleProgressMouseUp(e) {
            if (!state.isDraggingProgress) return;
            state.isDraggingProgress = false;
            document.body.style.userSelect = ''; // Re-enable selection

            // Final update ensures correct time even if throttled
            player.handleProgressDrag(e);

            if (state.wasPlayingBeforeDrag) {
                // Resume playing only if it's actually paused and safe to do so
                setTimeout(() => {
                    if (elements.audioPlayer.paused && !state.hasError && !state.isLoading && !state.isEmpty) {
                        const resumePromise = elements.audioPlayer.play();
                        if (resumePromise !== undefined) {
                            resumePromise.catch(error => {
                                if (error.name !== 'AbortError') {
                                    player.handleAudioError(error, state.currentTrackIndex);
                                }
                                // Ensure UI reflects actual state if resume fails
                                if (state.isPlaying) { state.isPlaying = false; }
                                player.updateButtonUI(false);
                                player.updateVisuals(false);
                            });
                        }
                    } else if (state.isPlaying) {
                        // If somehow it started playing again, ensure animation is running
                        player.startProgressAnimation();
                    }
                }, 10); // Small delay
            } else {
                 // If it was paused before drag, update tonearm position
                 const { duration, currentTime } = elements.audioPlayer;
                 if (duration > 0) {
                    const progress = currentTime / duration;
                    const targetAngle = TONEARM_ANGLES.RESTING + (TONEARM_ANGLES.START - TONEARM_ANGLES.RESTING) * progress;
                    const clampedAngle = Math.max(TONEARM_ANGLES.RESTING, Math.min(TONEARM_ANGLES.START, targetAngle));
                     elements.tonearmRotator.style.transition = ''; // Temporarily disable transition for immediate snap
                     elements.tonearmRotator.style.transform = `rotate(${clampedAngle}deg)`;
                     // Re-enable transition shortly after
                     setTimeout(() => { elements.tonearmRotator.style.transition = ''; }, 50);
                 }
            }
            state.wasPlayingBeforeDrag = false; // Reset flag
        },

        handleProgressDrag(e) {
             const { duration } = elements.audioPlayer;
            if (!duration || isNaN(duration) || duration <= 0) return;

            const rect = elements.progressContainer.getBoundingClientRect();
            const { clientX } = utils.getEventCoords(e);
            const clickX = clientX - rect.left;
            let progress = Math.min(1, Math.max(0, clickX / rect.width));

            const newTime = progress * duration;
            if (Math.abs(elements.audioPlayer.currentTime - newTime) > 0.1) {
               elements.audioPlayer.currentTime = newTime;
            }

            // Update visuals immediately
            elements.progressBar.style.width = `${progress * 100}%`;
            elements.currentTimeDisplay.textContent = utils.formatTime(elements.audioPlayer.currentTime);
            elements.progressContainer.setAttribute('aria-valuenow', Math.round(elements.audioPlayer.currentTime));
            elements.progressContainer.setAttribute('aria-valuetext', `当前 ${utils.formatTime(elements.audioPlayer.currentTime)} / 总时长 ${utils.formatTime(duration)}`);
        }
    };

    // --- Event Listener Setup ---
    const setupEventListeners = () => {
        elements.playPauseButton.addEventListener('click', player.togglePlayPause);
        elements.prevButton.addEventListener('click', player.playPrevTrack);
        elements.nextButton.addEventListener('click', player.playNextTrack);

        // Progress Bar Interaction
        elements.progressContainer.addEventListener('click', player.handleProgressClick);
        elements.progressContainer.addEventListener('mousedown', player.handleProgressMouseDown);
        elements.progressContainer.addEventListener('touchstart', player.handleProgressMouseDown, { passive: false });

        // Tonearm Interaction
        elements.tonearmBar.addEventListener('mousedown', player.handleTonearmMouseDown);
        elements.tonearmBar.addEventListener('touchstart', player.handleTonearmMouseDown, { passive: false });

        // Document-level listeners for dragging
        document.addEventListener('mousemove', (e) => {
            if (state.isDraggingProgress) player.handleProgressMouseMove(e);
            if (state.isDraggingTonearm) player.handleTonearmMouseMove(e);
        });
        document.addEventListener('touchmove', (e) => {
             // Prevent scroll ONLY when actively dragging relevant elements
            if (state.isDraggingProgress || state.isDraggingTonearm) {
                 e.preventDefault();
                 if (state.isDraggingProgress) player.handleProgressMouseMove(e);
                 if (state.isDraggingTonearm) player.handleTonearmMouseMove(e);
            }
        }, { passive: false });
        document.addEventListener('mouseup', (e) => {
             // Only fire handlers if the corresponding drag was active
            if (state.isDraggingProgress) player.handleProgressMouseUp(e);
            if (state.isDraggingTonearm) player.handleTonearmMouseUp(e);
        });
        document.addEventListener('touchend', (e) => {
            if (state.isDraggingProgress) player.handleProgressMouseUp(e);
            if (state.isDraggingTonearm) player.handleTonearmMouseUp(e);
        });
         document.addEventListener('touchcancel', (e) => { // Handle interrupted touches
            if (state.isDraggingProgress) player.handleProgressMouseUp(e);
            if (state.isDraggingTonearm) player.handleTonearmMouseUp(e);
        });

        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            const activeEl = document.activeElement;
            // Check if focus is on something that shouldn't trigger global spacebar play/pause
            const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable || activeEl.closest('button, [role=slider]'));
            if (e.code === 'Space' && !isInputFocused) {
                e.preventDefault();
                player.togglePlayPause();
            }
            // Add Left/Right arrow for seeking? Example:
            // else if (e.code === 'ArrowLeft' && !isInputFocused) {
            //     e.preventDefault();
            //     elements.audioPlayer.currentTime = Math.max(0, elements.audioPlayer.currentTime - 5);
            //     player.updateProgressBar();
            // } else if (e.code === 'ArrowRight' && !isInputFocused) {
            //     e.preventDefault();
            //     elements.audioPlayer.currentTime = Math.min(elements.audioPlayer.duration || 0, elements.audioPlayer.currentTime + 5);
            //     player.updateProgressBar();
            // }
        });

        // --- Audio Element Events ---
        elements.audioPlayer.addEventListener('play', () => {
            state.isPlaying = true;
            player.updateButtonUI(true);
            player.updateVisuals(true);
            player.startProgressAnimation();
            if (state.isLoading) { player.setLoadingState(false); }
        });

        elements.audioPlayer.addEventListener('pause', () => {
            state.isPlaying = false;
            // Only update UI if pause wasn't triggered by starting a progress drag
            if (!state.isDraggingProgress) {
                player.updateButtonUI(false);
                player.updateVisuals(false);
                player.stopProgressAnimation();
            } else {
                 // If paused because drag started, ensure visuals reflect pause state immediately
                 player.updateButtonUI(false);
                 player.updateVisuals(false);
            }
        });

        elements.audioPlayer.addEventListener('ended', () => {
            state.isPlaying = false; // Ensure state is correct before loading next
            player.updateButtonUI(false);
            player.updateVisuals(false);
            player.stopProgressAnimation();
            player.playNextTrack();
        });

        elements.audioPlayer.addEventListener('timeupdate', () => {
            if (!state.isDraggingTonearm && !state.isDraggingProgress) {
                player.updateProgressBar();
            }
        });

        elements.audioPlayer.addEventListener('loadedmetadata', () => {
            player.updateProgressBar(); // Update duration display
            // Metadata doesn't guarantee readiness for play, but controls can be enabled
            player.setControlsEnabled(true);
            if (state.isLoading) {
                 // Don't necessarily turn off loading here, wait for loadeddata or playing
            }
        });

        elements.audioPlayer.addEventListener('loadeddata', () => {
             // This indicates enough data is loaded to start playing
            if (state.isLoading) {
                player.setLoadingState(false);
            }
            player.setControlsEnabled(true);
        });

        elements.audioPlayer.addEventListener('waiting', () => {
            // Show loading only if it was supposed to be playing
            if (state.isPlaying && !state.isLoading) {
                 player.setLoadingState(true);
            }
        });

        elements.audioPlayer.addEventListener('playing', () => {
            // Playback resumed after buffering/seek/initial play
            if (state.isLoading) {
                player.setLoadingState(false);
            }
             // Ensure state/UI sync if 'play' event was missed or state got desynced
            if (!state.isPlaying) { state.isPlaying = true; }
            player.updateButtonUI(true);
            player.updateVisuals(true);
            player.startProgressAnimation();
        });

        // Global audio error handler (already assigned during loadTrack)
        // elements.audioPlayer.addEventListener('error', (e) => player.handleAudioError(e, state.currentTrackIndex)); // This is dynamically assigned

        // Album Art Error Fallback
        elements.albumArt.addEventListener('error', () => {
            if (elements.albumArt.src && !elements.albumArt.src.includes("placeholder.com")) {
                elements.albumArt.src = "https://via.placeholder.com/200?text=No+Cover";
                elements.albumArt.alt = "无法加载封面";
            }
        });
    };

    // --- Initialization ---
    const init = () => {
        setupEventListeners();
        player.setControlsEnabled(false); // Initially disable

        if (!state.playlist || state.playlist.length === 0) {
            player.setEmptyState(true);
        } else {
            player.setEmptyState(false);
            player.loadTrack(0, false); // Load first track, don't autoplay
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

  </script>
</body>
</html>